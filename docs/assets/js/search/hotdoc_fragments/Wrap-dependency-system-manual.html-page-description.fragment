fragment_downloaded_cb({"url": "Wrap-dependency-system-manual.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"Wrap-dependency-system-manual.md\">\n<h1 id=\"wrap-dependency-system-manual\">Wrap dependency system manual</h1>\n<p>One of the major problems of multiplatform development is wrangling all your dependencies. This is easy on Linux where you can use system packages but awkward on other platforms. Most of those do not have a package manager at all. This has been worked around by having third party package managers. They are not really a solution for end user deployment, because you can't tell them to install a package manager just to use your app. On these platforms you must produce self-contained applications.</p>\n<p>The traditional approach to this has been to bundle dependencies inside your own project. Either as prebuilt libraries and headers or by embedding the source code inside your source tree and rewriting your build system to build them as part of your project.</p>\n<p>This is both tedious and error prone because it is always done by hand. The Wrap dependency system of Meson aims to provide an automated way to do this.</p>\n<h2 id=\"how-it-works\">How it works</h2>\n<p>Meson has a concept of <a href=\"Subprojects.html\">subprojects</a>. They are a way of nesting one Meson project inside another. Any project that builds with Meson can detect that it is built as a subproject and build itself in a way that makes it easy to use (usually this means as a static library).</p>\n<p>To use this kind of a project as a dependency you could just copy and extract it inside your project's <code>subprojects</code> directory. However there is a simpler way. You can specify a Wrap file that tells Meson how to download it for you. An example wrap file would look like this and should be put in <code>subprojects/foobar.wrap</code>:</p>\n<pre><code class=\"language-ini\">[wrap-file]\ndirectory = libfoobar-1.0\n\nsource_url = http://example.com/foobar-1.0.tar.gz\nsource_filename = foobar-1.0.tar.gz\nsource_hash = 5ebeea0dfb75d090ea0e7ff84799b2a7a1550db3fe61eb5f6f61c2e971e57663\n</code></pre>\n<p>If you then use this subproject in your build, Meson will automatically download and extract it during build. This makes subproject embedding extremely easy.</p>\n<p>Unfortunately most software projects in the world do not build with Meson. Because of this Meson allows you to specify a patch url. This works in much the same way as Debian's distro patches. That is, they are downloaded and automatically applied to the subproject. These files contain a Meson build definition for the given subproject. A wrap file with an additional patch url would look like this.</p>\n<pre><code>[wrap-file]\ndirectory = libfoobar-1.0\n\nsource_url = http://upstream.example.com/foobar-1.0.tar.gz\nsource_filename = foobar-1.0.tar.gz\nsource_hash = 5ebeea0dfb75d090ea0e7ff84799b2a7a1550db3fe61eb5f6f61c2e971e57663\n\npatch_url = https://myserver.example.com/libfoobar-meson.tar.gz\npatch_filename = libfoobar-meson.tar.gz\npatch_hash = 8c9d00702d5fe4a6bf25a36b821a332f6b2dfd117c66fe818b88b23d604635e9\n</code></pre>\n<p>In this example the Wrap manager would download the patch and unzip it in libfoobar's directory.</p>\n<p>This approach makes it extremely simple to embed dependencies that require build system changes. You can write the Meson build definition for the dependency in total isolation. This is a lot better than doing it inside your own source tree, especially if it contains hundreds of thousands of lines of code. Once you have a working build definition, just zip up the Meson build files (and others you have changed) and put them somewhere where you can download them.</p>\n<h2 id=\"branching-subprojects-directly-from-git\">Branching subprojects directly from git</h2>\n<p>The above mentioned scheme assumes that your subproject is working off packaged files. Sometimes you want to check code out directly from Git. Meson supports this natively. All you need to do is to write a slightly different wrap file.</p>\n<pre><code>[wrap-git]\ndirectory=samplesubproject\nurl=https://github.com/jpakkane/samplesubproject.git\nrevision=head\n</code></pre>\n<p>The format is straightforward. The only thing to note is the revision element that can have one of two values. The first is <code>head</code> which will cause Meson to track the master head (doing a repull whenever the build definition is altered). The second type is a commit hash. In this case Meson will use the commit specified (with <code>git checkout [hash id]</code>).</p>\n<p>Note that in this case you cannot specify an extra patch file to use. The git repo must contain all necessary Meson build definitions.</p>\n<p>Usually you would use subprojects as read only. However in some cases you want to do commits to subprojects and push them upstream. For these cases you can specify the upload url by adding the following at the end of your wrap file:</p>\n<pre><code class=\"language-ini\">push-url=git@git.example.com:projects/someproject.git # Supported since version 0.37.0\n</code></pre>\n<h2 id=\"using-wrapped-projects\">Using wrapped projects</h2>\n<p>To use a subproject simply do this in your top level <code>meson.build</code>.</p>\n<pre><code class=\"language-meson\">foobar_sp = subproject('foobar')\n\nUsually dependencies consist of some header files plus a library to link against. To do this you would declare this internal dependency like this:\n\n```meson\nfoobar_dep = declare_dependency(link_with : mylib,\n  include_directories : myinc)\n</code></pre>\n<p>Then in your main project you would use them like this:</p>\n<pre><code class=\"language-meson\">executable('toplevel_exe', 'prog.c',\n  dependencies : foobar_sp.get_variable('foobar_dep'))\n</code></pre>\n<p>Note that the subproject object is <em>not</em> used as the dependency, but rather you need to get the declared dependency from it with <code>get_variable</code> because a subproject may have multiple declared dependencies.</p>\n<h2 id=\"toggling-between-distro-packages-and-embedded-source\">Toggling between distro packages and embedded source</h2>\n<p>When building distro packages it is very important that you do not embed any sources. Some distros have a rule forbidding embedded dependencies so your project must be buildable without them or otherwise the packager will hate you.</p>\n<p>Doing this with Meson and Wrap is simple. Here's how you would use distro packages and fall back to embedding if the dependency is not available.</p>\n<pre><code class=\"language-meson\">foobar_dep = dependency('foobar', required : false)\n\nif not foobar_dep.found()\n  foobar_subproj = subproject('foobar')\n  # the subproject defines an internal dependency with\n  # the command declare_dependency().\n  foobar_dep = foobar_subproj.get_variable('foobar_dep')\nendif\n\nexecutable('toplevel_exe', 'prog.c',\n  dependencies : foobar_dep)\n</code></pre>\n<p>Because this is such a common operation, Meson provides a shortcut for this use case.</p>\n<pre><code class=\"language-meson\">foobar_dep = dependency('foobar', fallback : ['foobar', 'foobar_dep'])\n</code></pre>\n<p>The <code>fallback</code> keyword argument takes two items, the name of the subproject and the name of the variable that holds the dependency. If you need to do something more complicated, such as extract several different variables, then you need to do it yourself with the manual method described above.</p>\n<p>With this setup when foobar is provided by the system, we use it. When that is not the case we use the embedded version. Note that <code>foobar_dep</code> can point to an external or an internal dependency but you don't have to worry about their differences. Meson will take care of the details for you.</p>\n<h2 id=\"getting-wraps\">Getting wraps</h2>\n<p>Usually you don't want to write your wraps by hand. There is an online repository called [WrapDB](Using the WrapDB) that provides many dependencies ready to use.</p>\n\n</div>\n\n\n        "});