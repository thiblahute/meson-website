fragment_downloaded_cb({"url": "Dependencies.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"Dependencies.md\">\n<h1 id=\"dependencies\">Dependencies</h1>\n<p>Very few applications are fully self-contained, but rather they use external libraries and frameworks to do their work. Meson makes it very easy to find and use external dependencies. Here is how one would use the Zlib compression library.</p>\n<pre><code class=\"language-meson\">zdep = dependency('zlib', version : '&gt;=1.2.8')\nexe = executable('zlibprog', 'prog.c', dependencies : zdep)\n</code></pre>\n<p>First Meson is told to find the external library <code>zlib</code> and error out if it is not found. The <code>version</code> keyword is optional and specifies a version requirement for the dependency. Then an executable is built using the specified dependency. Note how the user does not need to manually handle compiler or linker flags or deal with any other minutiae.</p>\n<p>If you have multiple dependencies, pass them as an array:</p>\n<pre><code class=\"language-meson\">executable('manydeps', 'file.c', dependencies : [dep1, dep2, dep3, dep4])\n</code></pre>\n<p>If the dependency is optional, you can tell Meson not to error out if the dependency is not found and then do further configuration.</p>\n<pre><code class=\"language-meson\">opt_dep = dependency('somedep', required : false)\nif opt_dep.found()\n  # Do something.\nelse\n  # Do something else.\nendif\n</code></pre>\n<p>You can pass the <code>opt_dep</code> variable to target construction functions whether the actual dependency was found or not. Meson will ignore non-found dependencies.</p>\n<p>The dependency detector works with all libraries that provide a <code>pkg-config</code> file. Unfortunately several packages don't provide pkg-config files. Meson has autodetection support for some of these.</p>\n<h2 id=\"boost\">Boost</h2>\n<p>Boost is not a single dependency but rather a group of different libraries. To use Boost with Meson, simply list which Boost modules you would like to use.</p>\n<pre><code class=\"language-meson\">boost_dep = dependency('boost', modules : ['thread', 'utility'])\nexe = executable('myprog', 'file.cc', dependencies : boost_dep)\n</code></pre>\n<p>You can call <code>dependency</code> multiple times with different modules and use those to link against your targets.</p>\n<h2 id=\"gtest-and-gmock\">GTest and GMock</h2>\n<p>GTest and GMock come as sources that must be compiled as part of your project. With Meson you don't have to care about the details, just pass <code>gtest</code> or <code>gmock</code> to <code>dependency</code> and it will do everything for you. If you want to use GMock, it is recommended to use GTest as well, as getting it to work standalone is tricky.</p>\n<h2 id=\"qt5\">Qt5</h2>\n<p>Meson has native Qt5 support. Its usage is best demonstrated with an example.</p>\n<pre><code class=\"language-meson\">qt5_mod = import('qt5')\nqt5widgets = dependency('qt5', modules : 'Widgets')\n\nprocessed = qt5_mod.preprocess(\n  moc_headers : 'mainWindow.h',   # Only headers that need moc should be put here\n  moc_sources : 'helperFile.cpp', # must have #include\"moc_helperFile.cpp\"\n  ui_files    : 'mainWindow.ui',\n  qresources  : 'resources.qrc',\n)\n\nq5exe = executable('qt5test',\n  sources     : ['main.cpp',\n                 'mainWindow.cpp',\n                 processed],\n  dependencies: qt5widgets)\n</code></pre>\n<p>Here we have an UI file created with Qt Designer and one source and header file each that require preprocessing with the <code>moc</code> tool. We also define a resource file to be compiled with <code>rcc</code>. We just have to tell Meson which files are which and it will take care of invoking all the necessary tools in the correct order, which is done with the <code>preprocess</code> method of the <code>qt5</code> module. Its output is simply put in the list of sources for the target. The <code>modules</code> keyword of <code>dependency</code> works just like it does with Boost. It tells which subparts of Qt the program uses.</p>\n<h2 id=\"declaring-your-own\">Declaring your own</h2>\n<p>You can declare your own dependency objects that can be used interchangeably with dependency objects obtained from the system. The syntax is straightforward:</p>\n<pre><code class=\"language-meson\">my_inc = include_directories(...)\nmy_lib = static_library(...)\nmy_dep = declare_dependency(link_with : my_lib,\n  include_directories : my_inc)\n</code></pre>\n<p>This declares a dependency that adds the given include directories and static library to any target you use it in.</p>\n\n</div>\n\n\n        "});