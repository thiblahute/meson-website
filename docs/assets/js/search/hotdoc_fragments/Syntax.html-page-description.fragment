fragment_downloaded_cb({"url": "Syntax.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"Syntax.md\">\n<h1 id=\"syntax\">Syntax</h1>\n<p>The syntax of Meson's specification language has been kept as simple as possible. It is <em>strongly typed</em> so no object is ever converted to another under the covers. Variables have no visible type which makes Meson <em>dynamically typed</em> (also known as <em>duck typed</em>).</p>\n<p>The main building blocks of the language are <em>variables</em>, <em>numbers</em>, <em>booleans</em>, <em>strings</em>, <em>arrays</em>, <em>function calls</em>, <em>method calls</em>, <em>if statements</em> and <em>includes</em>.</p>\n<p>Usually one Meson statement takes just one line. There is no way to have multiple statements on one line as in e.g. <em>C</em>. Function and method calls' argument lists can be split over multiple lines. Meson will autodetect this case and do the right thing. Apart from line ending whitespace has no syntactical meaning.</p>\n<h2 id=\"variables\">Variables</h2>\n<p>Variables in Meson work just like in other high level programming languages. A variable can contain a value of any type, such as an integer or a string. Variables don't need to be predeclared, you can just assign to them and they appear. Here's how you would assign values to two different variables.</p>\n<pre><code class=\"language-meson\">var1 = 'hello'\nvar2 = 102\n</code></pre>\n<p>One important difference in how variables work in Meson is that all variables are immutable. This is different from, for example, how Python works.</p>\n<pre><code class=\"language-meson\">var1 = [1, 2, 3]\nvar2 = var1\nvar2 += [4]\n# var2 is now [1, 2, 3, 4]\n# var1 is still [1, 2, 3]\n</code></pre>\n<h2 id=\"numbers\">Numbers</h2>\n<p>Meson supports only integer numbers. They are declared simply by writing them out. Basic arithmetic operations are supported.</p>\n<pre><code class=\"language-meson\">x = 1 + 2\ny = 3 * 4\nd = 5 % 3 # Yields 2.\n</code></pre>\n<p>Strings can be converted to a number like this:</p>\n<pre><code class=\"language-meson\">string_var = '42'\nnum = var1.to_int()\n</code></pre>\n<h2 id=\"booleans\">Booleans</h2>\n<p>A boolean is either <code>true</code> or <code>false</code>.</p>\n<pre><code class=\"language-meson\">truth = true\n</code></pre>\n<h2 id=\"strings\">Strings</h2>\n<p>Strings in Meson are declared with single quotes. To enter a literal single quote do it like this:</p>\n<pre><code class=\"language-meson\">single quote = 'contains a \\' character'\n</code></pre>\n<p>Similarly <code>\\n</code> gets converted to a newline and <code>\\\\\\\\</code> to a single backslash.</p>\n<h4 id=\"strings-running-over-multiple-lines\">Strings running over multiple lines</h4>\n<p>Strings running over multiple lines can be declared with three single quotes, like this:</p>\n<pre><code class=\"language-meson\">multiline_string = '''#include &lt;foo.h&gt;\nint main (int argc, char ** argv) {\n  return FOO_SUCCESS;\n}'''\n</code></pre>\n<p>This can also be combined with the string formatting functionality described below.</p>\n<h4 id=\"string-formatting\">String formatting</h4>\n<p>Strings can be built using the string formatting functionality.</p>\n<pre><code class=\"language-meson\">template = 'string: @0@, number: @1@, bool: @2@'\nres = template.format('text', 1, true)\n# res now has value 'string: text, number: 1, bool: true'\n</code></pre>\n<p>As can be seen, the formatting works by replacing placeholders of type <code>@number@</code> with the corresponding argument.</p>\n<h4 id=\"string-methods\">String methods</h4>\n<p>Strings also support a number of other methods that return transformed copies.</p>\n<p><strong>.strip()</strong></p>\n<pre><code class=\"language-meson\"># Similar to the Python str.strip(). Removes leading/ending spaces and newlines\ndefine = ' -Dsomedefine '\nstripped_define = target.strip()\n# 'stripped_define' now has the value '-Dsomedefine'\n</code></pre>\n<p><strong>.to_upper()</strong>, <strong>.to_lower()</strong></p>\n<pre><code class=\"language-meson\">target = 'x86_FreeBSD'\nupper = target.to_upper() # t now has the value 'X86_FREEBSD'\nlower = target.to_lower() # t now has the value 'x86_freebsd'\n</code></pre>\n<p><strong>.to_int()</strong></p>\n<pre><code class=\"language-meson\">version = '1'\n# Converts the string to an int and throws an error if it can't be\nver_int = version.to_int()\n</code></pre>\n<p><strong>.contains()</strong>, <strong>.startswith()</strong>, <strong>.endswith()</strong></p>\n<pre><code class=\"language-meson\">target = 'x86_FreeBSD'\nis_fbsd = target.to_lower().contains('freebsd')\n# is_fbsd now has the boolean value 'true'\nis_x86 = target.startswith('x86') # boolean value 'true'\nis_bsd = target.to_lower().endswith('bsd') # boolean value 'true'\n</code></pre>\n<p><strong>.split()</strong>, <strong>.join()</strong></p>\n<pre><code class=\"language-meson\"># Similar to the Python str.split()\ncomponents = 'a b   c d '.split()\n# components now has the value ['a', 'b', 'c', 'd']\ncomponents = 'a b   c d '.split(' ')\n# components now has the value ['a', 'b', '', '', 'c', 'd', '']\n\n# Similar to the Python str.join()\noutput = ' '.join(['foo', 'bar'])\n# Output value is 'foo bar'\npathsep = ':'\npath = pathsep.join(['/usr/bin', '/bin', '/usr/local/bin'])\n# path now has the value '/usr/bin:/bin:/usr/local/bin'\n\n# For joining paths, you should use join_paths()\n# This has the advantage of being cross-platform\npath = join_paths(['/usr', 'local', 'bin'])\n# path now has the value '/usr/local/bin'\n\n# Example to set an API version for use in library(), install_header(), etc\nproject('project', 'c', version: '0.2.3')\nversion_array = meson.project_version().split('.')\n# version_array now has the value ['0', '2', '3']\napi_version = '.'.join([version_array[0], version_array[1]])\n# api_version now has the value '0.2'\n\n# We can do the same with .format() too:\napi_version = '@0@.@1@'.format(version_array[0], version_array[1])\n# api_version now (again) has the value '0.2'\n</code></pre>\n<p><strong>.underscorify()</strong></p>\n<pre><code class=\"language-meson\">name = 'Meson Docs.txt#Reference-manual'\n# Replaces all characters other than `a-zA-Z0-9` with `_` (underscore)\n# Useful for substituting into #defines, filenames, etc.\nunderscored = name.underscorify()\n# underscored now has the value 'Meson_Docs_txt_Reference_manual'\n</code></pre>\n<p><strong>.version_compare()</strong></p>\n<pre><code class=\"language-meson\">version = '1.2.3'\n# Compare version numbers semantically\nis_new = version.version_compare('&gt;=2.0')\n# is_new now has the boolean value false\n# Supports the following operators: '&gt;', '&lt;', '&gt;=', '&lt;=', '!=', '==', '='\n</code></pre>\n<h2 id=\"arrays\">Arrays</h2>\n<p>Arrays are delimited by brackets. An array can contain an arbitrary number of objects of any type.</p>\n<pre><code class=\"language-meson\">my_array = [1, 2, 'string', some_obj]\n</code></pre>\n<p>You can add additional items to an array like this:</p>\n<pre><code class=\"language-meson\">my_array += [ 'foo', 3, 4, another_obj ]\n</code></pre>\n<h4 id=\"array-methods\">Array methods</h4>\n<p>The following methods are defined for all arrays:</p>\n<ul>\n<li><code>length</code>, the size of the array</li>\n<li><code>contains</code>, returns <code>true</code> if the array contains the object given as argument, <code>false</code> otherwise</li>\n<li><code>get</code>, returns the object at the given index, negative indices count from the back of the array, indexing out of bounds is a fatal error</li>\n</ul>\n<h2 id=\"function-calls\">Function calls</h2>\n<p>Meson provides a set of usable functions. The most common use case is creating build objects.</p>\n<pre><code class=\"language-meson\">executable('progname', 'prog.c')\n</code></pre>\n<h2 id=\"method-calls\">Method calls</h2>\n<p>Objects can have methods, which are called with the dot operator. The exact methods it provides depends on the object.</p>\n<pre><code class=\"language-meson\">myobj = some_function()\nmyobj.do_something('now')\n</code></pre>\n<h2 id=\"if-statements\">If statements</h2>\n<p>If statements work just like in other languages.</p>\n<pre><code class=\"language-meson\">var1 = 1\nvar2 = 2\nif var1 == var2 # Evaluates to false\n  something_broke()\nelif var3 == var2\n  something_else_broke()\nelse\n  everything_ok()\nendif\n\nopt = get_option('someoption')\nif opt == 'foo'\n  do_something()\nendif\n</code></pre>\n<h2 id=\"foreach-statements\">Foreach statements</h2>\n<p>To do an operation on all elements of an array, use the <code>foreach</code> command. As an example, here's how you would define two executables with corresponding tests.</p>\n<pre><code class=\"language-meson\">progs = [['prog1', ['prog1.c', 'foo.c']],\n         ['prog2', ['prog2.c', 'bar.c']]]\n\nforeach p : progs\n  exe = executable(p[0], p[1])\n  test(p[0], exe)\nendforeach\n</code></pre>\n<p>Note that Meson variables are immutable. Trying to assign a new value to <code>progs</code> inside a foreach loop will not affect foreach's control flow.</p>\n<h2 id=\"logical-operations\">Logical operations</h2>\n<p>Meson has the standard range of logical operations.</p>\n<pre><code class=\"language-meson\">if a and b\n  # do something\nendif\nif c or d\n  # do something\nendif\nif not e\n  # do something\nendif\nif not (f or g)\n  # do something\nendif\n</code></pre>\n<p>Logical operations work only on boolean values.</p>\n<h2 id=\"comments\">Comments</h2>\n<p>A comment starts with the <code>#</code> character and extends until the end of the line.</p>\n<pre><code class=\"language-meson\">some_function() # This is a comment\nsome_other_function()\n</code></pre>\n<h2 id=\"ternary-operator\">Ternary operator</h2>\n<p>The ternary operator works just like in other languages.</p>\n<pre><code class=\"language-meson\">x = condition ? true_value : false_value\n</code></pre>\n<p>The only exception is that nested ternary operators are forbidden to improve legibility. If your branching needs are more complex than this you need to write an <code>if/else</code> construct.</p>\n<h2 id=\"includes\">Includes</h2>\n<p>Most source trees have multiple subdirectories to process. These can be handled by Meson's <code>subdir</code> command. It changes to the given subdirectory and executes the contents of <code>meson.build</code> in that subdirectory. All state (variables etc) are passed to and from the subdirectory. The effect is roughly the same as if the contents of the subdirectory's Meson file would have been written where the include command is.</p>\n<pre><code class=\"language-meson\">test_data_dir = 'data'\nsubdir('tests')\n</code></pre>\n\n</div>\n\n\n        "});