fragment_downloaded_cb({"url": "Design-rationale.html#page-description", "fragment": "This is the original design rationale for Meson. The syntax it describes does not match the released version \nA software developer s most important tool is the editor. If you talk to coders about the editors they use you are usually met with massive enthusiasm and praise. You will hear how Emacs is the greatest thing ever or how vi is so elegant or how Eclipse s integration features make you so much more productive. You can sense the enthusiasm and affection that the people feel towards these programs. \nThe second most important tool even more important than the compiler is the build system. \nThose are pretty much universally despised. \nThe most positive statement on build systems you can usually get and it might require some coaxing is something along the lines of well it s a terrible system but all other options are even worse. It is easy to see why this is the case. For starters commonly used free build systems have obtuse syntaxes. They use for the most part global variables that are set in random locations so you can never really be sure what a given line of code does. They do strange and unpredictable things at every turn. \nLet s illustrate this with a simple example. Suppose we want to run a program built with GNU Autotools under gdb. The instinctive thing to do is to just run gdb programname. The problem is that this may or may not work. In some cases the executable file is a binary whereas at other times it is a wrapper shell script that invokes the real binary which resides in a hidden subdirectory. Gdb invocation fails if the binary is a script but succeeds if it is not. The user has to remember the type of each one of his executables which is an implementation detail of the build system just to be able to debug them. Several other such pain points can be found in this blog post. \nGiven these idiosyncrasies it is no wonder that most people don t want to have anything to do with build systems. They ll just copypaste code that works somewhat in one place to another and hope for the best. They actively go out of their way not to understand the system because the mere thought of it is repulsive. Doing this also provides a kind of inverse job security. If you don t know tool X there s less chance of finding yourself responsible for its use in your organisation. Instead you get to work on more enjoyable things. \nThis leads to a vicious circle. Since people avoid the tools and don t want to deal with them very few work on improving them. The result is apathy and stagnation. \n"});