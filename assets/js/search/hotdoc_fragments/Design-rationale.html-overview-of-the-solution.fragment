fragment_downloaded_cb({"url": "Design-rationale.html#overview-of-the-solution", "fragment": "Overview of the solution \nGoing over these requirements it becomes quite apparent that the only viable approach is roughly the same as taken by CMake having a domain specific language to declare the build system. Out of this declaration a configuration is generated for the backend build system. This can be a Makefile Visual Studio or XCode project or anything else. \nThe difference between the proposed DSL and existing ones is that the new one is declarative. It also tries to work on a higher level of abstraction than existing systems. As an example using external libraries in current build systems means manually extracting and passing around compiler flags and linker flags. In the proposed system the user just declares that a given build target uses a given external dependency. The build system then takes care of passing all flags and settings to their proper locations. This means that the user can focus on his own code rather than marshalling command line arguments from one place to another. \nA DSL is more work than the approach taken by SCons which is to provide the system as a Python library. However it allows us to make the syntax more expressive and prevent certain types of bugs by e.g. making certain objects truly immutable. The end result is again the same less work for the user. \nThe backend for Unix requires a bit more thought. The default choice would be Make. However it is extremely slow. It is not uncommon on large code bases for Make to take several minutes just to determine that nothing needs to be done. Instead of Make we use Ninja which is extremely fast. The backend code is abstracted away from the core so other backends can be added with relatively little effort. \n"});